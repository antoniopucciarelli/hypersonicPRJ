# forces computation -> aerodynamic coefficients for different Kn, Ma & AOA
# authors:
#	antonio pucciarelli
#	raffaele tirotta
#
# aim:
# --- compute aerodynamic coefficient using DSMC
#

# INITIALIZING CASE
# seed generation -> random properties for the simulation 
seed            12345
    
# setting up simulation type 
dimension       2
    
# setting up grid properties
global          gridcut 0.0 comm/sort yes 
    
# setting up boundary properties 
boundary        oo oo pp

# SETTING UP GRID 
# study box generation
create_box      ${xMin} ${xMax} ${yMin} ${yMax} ${zMin} ${zMax}

# grid generation 
create_grid     ${xNcells} ${yNcells} 1

# parallel computing settings
balance_grid    rcb part
fix             loadbalance balance 1000 1.1 rcb part

# SETTING UP PARTICLES PROPERTIES
# No. of particles | No. of simulated particles
global          nrho ${numberDensity} fnum ${numberSimulated}

# species properties loading
species         collisionProperties/marsAtmosphere.species CO2 N2

# mixture properties declaration
mixture     atmoMars CO2 N2 vstream ${Uflow} 0.0 0.0 temp ${Tflow} 	# name | molecules | speed | temperature 
mixture		atmoMars CO2 	frac 0.97				                # CO2 fraction
mixture		atmoMars N2  	frac 0.03				                # N2 fraction

# SURFACE PROPERTIES SETUP
# surface loading and rotation
read_surf       geometry/data.plate origin 0.0 0.0 0.0 rotate -${thetaAngle} 0 0 1

# COLLISION PROPERTIES
# surface collision properties
surf_collide    surfCollision diffuse 1500.0 1.0
surf_modify     all collide surfCollision

# molecule(s)/molecule(s) collision properties
collide 	    vss         atmoMars collisionProperties/marsAtmosphere.vss
collide_modify	vibrate     smooth

# REACTION SETUP
# problem set as non reactive
react		none

# INJECTION SETUP
# due to flow speed and thermal speed -> flow only from x[+ve], y[-ve] and y[+ve]
fix fixInject   emit/face atmoMars xlo ylo yhi

# TIME STEP DECLARATION
timestep        ${dt}

# PROPERTIES COMPUTATION
# force all over the surface 
compute         FORCEs      surf        all all             fx fy	                    # x|y direction 

# summing up all the forces and average them
fix             forceAVE    ave/surf    all 1 10 100        c_FORCEs[*] ave one         # average x|y direction 

# sum of the average forces 
compute         forceTOT    reduce      sum                 f_forceAVE[1] f_forceAVE[2] # total x|y direction 

# PLOTTING/PRINTING PROPERTIES
# every 100 time steps
stats           100     

# output setup
stats_style     step cpu c_forceTOT[1] c_forceTOT[2]

# doing the first run of the case in order to get a first approximation of the total drag force 
run     2000 

# SOLVING CASE WITH ITERATIVE PROCEDURE 
# setting up convergence study parameters
variable    fxTOTprev  equal   0.0
variable    fyTOTprev  equal   0.0
variable    tol        equal   1E-1

# printing variables 
print " " 
print "--- tol = ${tol}"
print " "

# PROPERTIES COMPUTATION

# summing up all the forces and average them
fix         forceAVE2      ave/surf    all 1 10 100     c_FORCEs[*] ave running 

# sum of the average forces 
compute     forceTOT2      reduce      sum              f_forceAVE2[1] f_forceAVE2[2]

# total force computation
variable    fxTOTnew    equal       c_forceTOT2[1]  
variable    fyTOTnew    equal       c_forceTOT2[2]

# setting up label for the while loop 
label checkConvergenceLabel

# PLOTTING/PRINTING PROPERTIES
# directory generation for result storage
shell 		mkdir dump
shell 		mkdir dump/Kn${iK}
shell		mkdir dump/Kn${iK}/Ma${iM}
shell 		mkdir dump/Kn${iK}/Ma${iM}/AOA${iA}
shell		mkdir dump/Kn${iK}/Ma${iM}/AOA${iA}/force
shell		mkdir dump/Kn${iK}/Ma${iM}/AOA${iA}/forceAverage
shell		mkdir dump/Kn${iK}/Ma${iM}/AOA${iA}/parcelsImage

# drag force storage
dump		dataDumpForce 			surf all 100 ./dump/Kn${iK}/Ma${iM}/AOA${iA}/force/xForce.* 				c_FORCEs[1]     c_FORCEs[2] 
# averaged drag force storage
dump 		dataDumpForceAverage 	surf all 100 ./dump/Kn${iK}/Ma${iM}/AOA${iA}/forceAverage/xForceAverage.* 	f_forceAVE2[1]  f_forceAVE2[2]
# figure printout 
dump       	figureDump              image all 200 ./dump/Kn${iK}/Ma${iM}/AOA${iA}/parcelsImage/image.*.ppm & 
                                    type type pdiam 0.01 surf proc 0.01 size 512 512 zoom 1.75 gline no 0.005 

# statistics printout 
stats_style     step cpu   v_fxTOTnew   v_fyTOTnew

# run case
run         2000

# undump command 
undump		dataDumpForce 
undump		dataDumpForceAverage
undump      figureDump

print '--- fxTOTnew = ${fxTOTnew}'
variable xForceNewTol   equal abs((${fxTOTnew}-${fxTOTprev})/${fxTOTnew})
variable yForceNewTol   equal abs((${fyTOTnew}-${fyTOTprev})/${fyTOTnew})
print '--- xForceNewTol   = ${xForceNewTol}'
print '--- yForceNewTol   = ${yForceNewTol}'

#check convergence
if '${xForceNewTol} > ${tol} && ${yForceNewTol} > ${tol}' then &
    'variable fxTOTprev equal ${fxTOTnew}'                     &
    'variable fyTOTprev equal ${fyTOTnew}'                     &
    'jump SELF checkConvergenceLabel'                          &
else "print '--- CONVERGENCE REACHED ---'"                                          
